%
% Day 16, Advent of code 2017 (Jonas Nockert / @lemonad)
%

% We can think of a move as a permutation of either letters or positions.
% One way to intuit it is ordered boxes with letters attached to them:
% if we rearrange the boxes, the letters are still attached to the same
% boxes as before -- and if we rearrange the letters, the boxes are still
% in their original positions.
%
% In that way we can take all the moves in our input and combine them
% into two permutations; one for letters and one for positions.
%
% Now, using the boxes and letters analogy: repeatedly applying the letter
% permutation, eventually we will get back to each letter being attached
% to the box it was attached to when we started (even though the boxes
% themselves might be in a different configuration). Repeatedly applying
% the position permutation, eventually we will get back to the boxes
% being placed the way they were when we started (even though different
% letters might be hanging on them).
%
% If we continue to apply both permutations, at some point the cycles
% will line up and we will have the boxes and letters as they were when
% we started. But this could take billions of applications, could it not?
%
% With 16 elements, there are not that many cycle lengths to combine.
% Using one cycle of length 16 repeats after only 16 permutations so we
% want to find the combination of smaller cycles that takes the longest
% to repeat.
%
% If we partition the 16 elements into cyclic groups of 16 = 4 + 5 + 7,
% together these cycles have a least common multiple of 140, which means
% they repeat after 140 applications.
%
% Using that partition for the permutation of letters, we now want to
% another partition for the permutation of boxes, that together takes
% the longest to repeat. We can't use the same partition as above
% because then both permutation cycles repeat after 140 applications.
%
% The next partition not sharing any common dividers > 1 with the above
% is 16 = 3 + 13, which repeats after 39 applications. Since none of
% these cycles share any common divisors > 1, if we combine all the
% cycles, they will repeat after 3 * 4 * 5 * 7 * 13 = 5460 applications.
%
% However, it's likely that our input data is based on partitions that
% include some cycle lengths with common divisors > 1 and thus repeat
% much earlier. Personally, I got two permutations with cycle lengths
% 15 + 1 (repeats after 15 applications) and 4 + 2 + 3 + 3 + 3
% (repeats after 12 applications):
%
%        positions: (1 10 12 13 5 9 7 14 16 2 11 3 8 4 15)(6)
%          letters: (a o f d)(b l)(c e j)(g m k)(h p i)
%
% Combined, they repeat after 60 applications.
%
% In this way, the moves could have been generated by random and the
% number of different states would never go above 5460.

% content = fileread('sample.in');
content = fileread('day16.in');
cdata = strtrim(content);
moves = strsplit(cdata, ',');


%
% Part one.
%

program = 'a':'p';
[position_perm, letter_perm] = movesToPerm(program, moves);
% Note that we can apply the permutations in any order.
program = applyPositionPermutation(program, position_perm);
program = applyLetterPermutation(program, letter_perm);
fprintf('Post dance: %s\n', program);
assert(isequal(program, 'cgpfhdnambekjiol'))

%
% Part two.
%

N = 1000000000;

program = 'a':'p';
% Find the cycle time and use that to make a minimum amount of moves.
n = findCycle(program, position_perm, letter_perm);
for i=floor(N / n) * n + 1:N
    program = applyLetterPermutation(program, letter_perm);
    program = applyPositionPermutation(program, position_perm);
end
fprintf('Post loooong dance: %s\n', program);
assert(isequal(program, 'gjmiofcnaehpdlbk'))


function n = findCycle(program, position_perm, letter_perm)
%FINDCYCLE Returns the cycle time of move permutations.
%   Note that we could optimize this by finding the cycle times
%   from the permutations insead and then calculate the least
%   common multiple. That would basically be be a loop over
%   32 elements instead of 5460 (worst case). Both are O(1)
%   in terms of N.
    orig = program;
    n = 1;
    while true
        program = applyLetterPermutation(program, letter_perm);
        program = applyPositionPermutation(program, position_perm);
        if isequal(orig, program)
            return
        end
        n = n + 1;
    end
end

function [position_perm, letter_perm] = movesToPerm(program, moves)
%MOVESTOPERM Combines moves into two permutations: positions and letters.
    position_program = program;
    for move = moves
        position_program = makePositionMove(position_program, move);
    end
    position_perm = position_program - 'a' + 1;

    letter_program = program;
    for move = moves
        letter_program = makeLetterMove(letter_program, move);
    end
    letter_perm = letter_program;
end

function out = makePositionMove(program, move)
%MAKEPOSITIONMOVE Make a move that permutes the positions.
    move = cell2mat(move);
    out = program;

    if move(1) == 'x'
        m = textscan(move(2:end), '%d/%d');
        pos1 = m{1} + 1;
        pos2 = m{2} + 1;
        out(pos1) = program(pos2);
        out(pos2) = program(pos1);
    elseif move(1) == 's'
        m = textscan(move(2:end), '%d');
        spin = m{1};
        out = [program(end - spin + 1:end), program(1:end - spin)];
    elseif move(1) == 'p'
    else
        error('Wrong move!');
    end
end

function out = makeLetterMove(program, move)
%MAKELETTERMOVE Make a move that permutes the letters.
    move = cell2mat(move);
    out = program;

    if move(1) == 'x' || move(1) == 's'
    elseif move(1) == 'p'
        m = textscan(move(2:end), '%c/%c');
        prg1 = m{1};
        prg2 = m{2};
        pos1 = strfind(program, prg1);
        pos2 = strfind(program, prg2);
        out(pos1) = program(pos2);
        out(pos2) = program(pos1);
     else
        error('Wrong move!');
    end
end

function program = applyPositionPermutation(program, position_perm)
%APPLYPOSITIONPERMUTATION Applies a permutation to the positions.
    p = program;
    for i = 1:length(position_perm)
        p(i) = program(position_perm(i));
    end
    program = p;
end

function program = applyLetterPermutation(program, letter_perm)
%APPLYLETTERPERMUTATION Applies a permutation to the letters.
    p = program;
    for i = 1:length(letter_perm)
        index = program(i) - 'a' + 1;
        p(i) = letter_perm(index);
    end
    program = p;
end
